<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	<title>Redactable Signature Schemes</title>
</head>

<body>
<h1>Redactable Signature Schemes</h1>

<p>
	Digital signature schemes are used to provide data integrity and data origin authentication for a signed message. A redactable signature scheme enables the attestation of a message in such a way that, if certain parts of the signed message (known as fields) are redacted (erased, blanked out or permanently removed), the attestation of the redacted message with respect to its integrity and origin authentication can still be verified. 
</p>
<p>
	More precisely, speaking of redactable signature schemes in general, it works as follows: The entity doing the signing (signer) splits the message into so-called message parts, usually based on semantic structures within the message, e.g. sentences or XML fragments. Upon signing a message, the signer knowing the private signature key can define which parts of the message can later be redacted (in the sense of ISO/IEC 27038) by any entity only knowing the message, the signature, and a so-called redaction key.  Any other modification of the signed message (e.g. redaction of other message parts or insertion/ modification of any parts) invalidates the attestation given by the signature. The possibility to define which parts are redactable and which are not is not possible in all algorithms. The redaction key consists of information that can be made publicly available and do not allow to infer the signer's secret key; in most algorithms this information is part of the signature. Thus, the entity doing the verification (verifier) just needs the message, the signature and the signer's public verification key.</p>
<p>
	Redactable signature schemes can serve as a basic building block in many privacy-preserving applications, such as privacy-preserving data sharing or authentication, where an entity can decide to only reveal the information from a larger set of signed information that is absolutely necessary to forward to a receiver, while the latter is still assured that the received information was previously attested, e.g. signed by a public authority.  
</p>

<p>
The following scheme variants can be selected in the step <b>Key Generation</b>:<br/>
<br/>
<b>1)</b> <a href="#GLRSS"><b>Accumulator-based RSS for linear documents (GLRSS)</b></a><br/>
<br/>
<b>2)</b> <a href="#GSRSS"><b>Accumulator-based RSS for sets (GSRSS)</b></a><br/>
<br/>
<b>3)</b> <a href="#GenericConstruction"><b>Generic Construction based on Hash-Trees (GC)</b></a><br/>
<br/>
<b>4)</b> <a href="#SBZ02-MersaProd"><b>Construction based on multi-exponent RSA algorithm (SBZ01-MERSAProd)</b></a><br/>
</p>
<p>GLRSS and GSRSS are based on the <a href="#BPA"><b>Baric Pfitzmann Accumulator (BPA)</b></a>.</p>
<p>The schemes have different cryptographic properties, which are explained in the section <a href="#properties"><b>Cryptographic properties</b></a>.</p>
<br>


<h2 id="properties">Cryptographic properties</h2>
<h3 id="detectability">Detectability of redaction</h3>
<p>Detectability of redaction means that any third party can distinguish a signed original message from a redacted signed message, e.g. directly signed {A,D} looks distinguishable from {A,-,-,D,-} obtained by redaction of a signed {A,B,C,D,E} assuming "-" is used as a special sign to indicate a redacted message part.</p>

<h3 id="undetectability">Undetectability of redaction</h3>
<p>Undetectability of redaction (in the original work termed "transparency" which is unfortunately ambiguous) means that an adversary cannot distinguished a signed original message from a redacted signed message.</p>

<h3 id="public_redaction">Public redaction</h3>
<p>Public redaction means that if authorized by the signer the respective redactable message part could be removed from the set without the need for additional keys. So public domain parameters are enough to successfully redact the message part by the receiver.</p>
<p>The notion public domain parameters refers to public information that is required to execute the specific algorithms, e.g. hash-functions or accumulator-functions, which are public and usually either known to the verifier, e.g. the padding functions of hash algorithms, or part of the signature. Note, those public domain parameters especially do not allow to generate new signatures, as this must always require the signer's secret key.</p>

<h3 id="private">Private redaction</h3>
<p>Private redaction means that the redacted message reveals no information about the content of the message part that was redacted, i.e. the adversary cannot distinguish on seeing a redacted message containing just m2=&quotC&quot that was generated by redacting m1 from either an original message m={m1,m2} with m1=&quotA&quot or an original message m'={m1',m2} with m1'=&quotB&quot.</p>

<h3 id="unforgeable">Unforgeable</h3>
<p>Unforgeable means that the adversary not in possession of the secret signature key cannot produce a signature that verifies on a message except for those messages that can be generated by carrying out one or more authorized &ndash;and thus public&ndash; redaction.</p>


<h2 id="BPA">Baric Pfitzmann Accumulator (BPA)</h2>
<p>In a nutshell, an accumulator scheme allows to represent a finite set X as a single succinct value, called the accumulator. One party having a secret can compute for each x element of X a so called witness, which certifies membership of x in X. Another party only given the accumulator value, the element x and the witness corresponding to the element can verify the membership proof. Without the secret it is not possible to generate verifying witness values. Without the witness it is not possible to verify if x was element of X for which one knows an accumulator.</p>
<p>The implementation in JCrypTool implements the accumulator scheme originally proposed by Barić and Pfitzmann [1] and has been slightly adjusted by De Meer, Liedl, Pöhls, Posegga and Samelin [2].</p>


<h2 id="GLRSS">Accumulator-based RSS for linear documents (GLRSS)</h2>
	<p>The RSS for linear documents (GLRSS) is based on a cryptographic accumulator scheme with certain cryptographic properties (e.g. <a href="#BPA">BPA</a>) and a digital signature scheme (e.g. RSA).<p>
	<p>Based on the explanation of an accumulator above (see <a href="#BPA">BPA</a>), the GSRSS is built as follows: It computes an accumulator value and all the witnesses representing the set to be signed and then it signs the accumulator value using any digital signature scheme. For verification, the verifier is simply provided the witnesses for each element in the set and it is verified whether the digital signature on the accumulator as well as the witnesses are valid. Redaction amounts to simply throwing away witnesses corresponding to redacted elements.</p>
	<p>In order to encode the order of the message parts the scheme takes special care, not just to take indices. Just taking indices would not result in undetectability of redactions, but would sometimes reveal their positions, e.g. redacting a signed list {1:A,2:B,3:C,4:D,5:E} into {1:A,4:D} would reveal that 2 elements between A and D were removed. This special care offers the cryptographic property of <a href="undetectablilty">undetectability of redactions</a>.</p>

	<p>This redactable signature scheme allows to <b>protect the integrity and data origin for the contents and as well as the order of the message parts</b>, additionally it allows the signer to <b>define which parts of the message are immutable</b>, i.e. fixed. Upon signature generation the signer defines the order of message parts and for each message part if it can be <a href="#public_redaction">publicly redacted</a>.</p>
	<p>Of course this scheme is <b><a href="#unforgeable">unforgeable</a></b>.</p>
	<p>Finally, the <b>redaction is <a href="#private">private</a></b>.</p>
	<p>Further, it remains <b>undetectable if a redaction has previously taken place</b> [3].</p>
	
	
<h2 id="GSRSS">Accumulator-based RSS for sets (GSRSS)</h2>
	<p>The RSS for sets (GSRSS) is based on a cryptographic accumulator scheme with certain cryptographic properties (e.g. <a href="#BPA">BPA</a>) and a digital signature scheme (e.g. RSA).</p>
	<p>GSRSS is built similar to <a href="#GLRSS">GLRSS</a>.</p>
	<p>However, the scheme published does not offer to control what element of the set is redactable and which is not, always all elements are redactable. This special care offers the cryptographic property of <a href="undetectablilty">undetectability of redactions</a>.</p></p>
	
	<p>This redactable signature scheme allows to<strong>&nbsp;protect the contents of message part, but not their order</strong>. Think of the message parts being a set in the mathematical sense.&nbsp;</p>
	<p>Additionally it allows the signer to <strong>define which parts of the message are immutable</strong>, i.e. fixed. Upon signature generation the signer defines mutually distinct message parts and for each message part if it can be <a href="#public_redaction">publicly redacted</a>.&nbsp;</p>
	<p>Of course this scheme is <strong><a href="#unforgeable">unforgeable</a></strong>.</p>
	<p>Finally, the <strong>redaction is</strong> <strong><a href="#private">private</a></strong>.</p>
	<p>Further, it remains <strong>undetectable if a redaction has previously taken place</strong> [3].</p>
	
	
<h2 id="GenericConstruction">Generic Construction based on Hash-Trees (GC)</h2>
	<p>The generic construction (GC) is based on a Merkle hash tree (see <a href="https://en.wikipedia.org/wiki/Merkle_tree">https://en.wikipedia.org/wiki/Merkle_tree</a>). The hash tree is a tree in which every leaf node is labelled with the cryptographic hash of a data block, and every non-leaf node is labelled with the cryptographic hash of the labels of its child nodes.</p>
	<p>Each leaf node is generated by hashing the contents of the message part together with two random values (one which is the same for all message parts; and one which is randomly chosen for each message part individually), in other words, the contents of the message parts and a random value are the data blocks over which the hash tree is built.</p>
	<p>A cryptographically secure hash function (e.g. SHA-3) has to be used and the root hash will depend on every message part. The root hash is finally signed using a digital signature scheme (e.g. RSA).</p>
	<p>In a nutshell, removing a message part would mean to remove their contents from the message and their random value and substitute it by providing just the hash. The scheme published does not offer to control what element of the set is redactable and which is not, always all elements are redactable</p>
	<p>The scheme further requires to provide information, i.e. the hash, for each of the redacted message parts, thus it offers the cryptographic property of <a href="#detectability">detectability of redactions</a>.</p>
	<p>Moreover, the scheme would allow to merge two different redacted versions generated from the same parent document (identified by the same message-wide random), e.g.  {A,-,-} and {-,B,-} when both obtained by redaction of a signed {A,B,C} can be merged into {A,B,-}, but the contents of the last message part C remain <a href="#private">private</a>, e.g. one cannot get any information about those contents.</p>
	
    <p>This redactable signature scheme allows to<strong>&nbsp;protect the contents of message parts, as well as their order</strong>. After signature generation all message parts can be <a href="#public_redaction">publicly redacted</a>.&nbsp;</p>
    <p>Of course this scheme is <strong><a href="#unforgeable">unforgeable</a></strong>.</p>
    <p>Finally, the <strong>redaction is</strong> <strong><a href="#private">private</a></strong>.</p>
    <p>However, any previous redaction remains <strong>detectable</strong>, e.g. leaves a trace [4].</p>
    
    
<h2 id="SBZ02-MersaProd">Construction based on multi-exponent RSA algorithm (SBZ01-MERSAProd)</h2>
	<p>The SBZ01-MERSAProd algorithm has its name from the original work. It is based on the RSA algorithm.</p>
	<p>Each message part requires one pair of public/private exponents, generated based on the multi-exponent RSA algorithm (see original work <a href="https://link.springer.com/chapter/10.1007/0-387-34805-0_17">https://link.springer.com/chapter/10.1007/0-387-34805-0_17</a> or a short write-up <a href="https://cryptome.org/jya/fiat-rsa.htm">https://cryptome.org/jya/fiat-rsa.htm</a>).</p>
	<p>In a nutshell it allows generating one RSA signature value (also called the batch signature) from many RSA signatures. This works as long as those signatures are generated from parameters using the same modulus (N). Hence, during key creation one has to generate a key-pair that contains as many exponents for the same modulus as one intends to sign message parts, i.e. the number of exponents must be greater or equal to the number of message parts. As it is RSA, one could generate missing exponent pairs also later if one still knows the factorisation of the modulus. However, if you want to create one public key, i.e. for having it certified by a third party or to distribute it to verifiers, you would need to know those public exponents that are used for signing the message, and include them in the distributed/certified public key.</p>
	<p>Each message part is signed using one exponent from the public key, and the signature for the message is the accumulated signature of all message parts' signatures. Removing a message part would mean to remove that part's signature from the overall signature. Therefore, the redaction requires to first extract all the individual signatures from the batch signature using the information from the original message parts. Then remove the message part and re-calculate the batch signature without the removed part's individual signature. Again a random value per message is added to avoid mixing message parts from individual messages, and substitute it by providing just the hash.</p>
	<p>The scheme published does offer to control what element of the set is redactable and which is not, by listing those that are non-redactable in a signed policy. </p>
	<p>The scheme further requires to provide information, i.e. the hash, for each of the redacted message parts, thus it offers the cryptographic property of <a href="#detectability">detectability of redactions</a>.</p>
	<p>Moreover, the scheme would allow to merge two different redacted versions generated from the same parent document (identified by the same message-wide random).</p>

	<p>This redactable signature scheme allows to<strong>&nbsp;protect the contents of message parts, as well as their order</strong>. After signature generation all message parts can be <a href="#public_redaction">publicly redacted</a>.&nbsp;</p>
	<p>Of course this scheme is <strong><a href="#unforgeable">unforgeable</a></strong>.</p>
	<p>Finally, the <strong>redaction is</strong> <strong><a href="#private">private</a></strong>.</p>
	<p>However, any previous redaction remains <strong>detectable</strong>, e.g. leaves a trace [4].</p>
	

<h2 id="sources">Sources</h2>
	<p>[1] Baric and Pfitzmann, "Collision-Free Accumulators and Fail-Stop Signature Schemes Without Trees" available in Proc. of Advances in Cryptology – EUROCRYPT ’97, volume 1233 of LNCS, pages 480–494. Springer, 1997.</p>
	<p>[2] De Meer, Liedl, Pöhls, Posegga and Samelin, "Indistinguishability of One-Way Accumulators" available as MIP-1210 at https://www.fim.uni-passau.de/forschung/technische-berichte/mip-1210/.</p>
	<p>[3] David Derler, Henrich C. Pöhls, Kai Samelin, and Daniel Slamanig, "A general framework for redactable signatures and new constructions" in Soonhak Kwon and Aaram Yun, editors, Information Security and Cryptology - ICISC 2015, pages 3–19, Springer, 2016.</p>
	<p>[4] R. Steinfeld, L. Bull, and Y. Zheng, "Content extraction signatures", ICISC, 2001.</p>


</body>
</html>

