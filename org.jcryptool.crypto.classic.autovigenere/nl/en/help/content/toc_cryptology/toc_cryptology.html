<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>

      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

	  <title>Autokey-Vigenère Cipher</title>
 <script src="${JCTJS_HOST}/javascript/jquery.js"></script> <!-- TODO: remove this and load automatically! Reason this is here is that certain onLoad methods require this early i.e. statically loaded. --> 
 <script>TOC_generate_default("h2, h3")</script> 
</head>
<body>

<h1>Autokey-Vigenère Cipher</h1>
<p>
	The Autokey-Vigenère cipher works like the Vigenère cipher, but appends the plaintext to the keyword instead of just extending the keyword to plaintext length.
</p>

<div class="TOC"></div> <hr /> 


<h2 id="classification">Classification</h2>
<p>
	The Autokey-Vigenère cipher is, like the pure Vigenère cipher, a polyalphabetic substitution cipher. In contrast to the pure Vigenère cipher, the effective "key" is constructed from the keyword and the plaintext itself, and not just from the infinite concatenation of the keyword. 
</p>


<h2 id="scheme">Input and output scheme</h2>
<img src="in_out_scheme.png"  width="85%" />


<h2 id="algorithm">The en- and decryption algorithm</h2>

<p>The Autokey-Vigenère cipher is, as the name says, a special Vigenère cipher, where the key (or the substitution alphabets or the Caesar alphabets) is generated not only from the keyword, but also from the plaintext. Besides the special key generation, there is no
difference to the normal Vigenère algorithm. So just the key generation and two examples (encryption and decryption) are explained here. Please refer to <a href="PLUGINS_ROOT/org.jcryptool.crypto.classic.vignere/$nl$/help/content/toc_cryptology/toc_cryptology.html">Vigenère Cipher</a> for the encryption and decryption functionality.</p>



<h3 id="Encryption">Encryption</h3>

<p>At the Vigenère algorithm, the substitution alphabets for each character of the plaintext were created, by using the components (numbers or letters of the plaintext alphabet) of the key word repeatedly (periodical appending of the key to itself until the length of the plaintext was reached). The Autokey-Vigenère algorithm is using the key word components
one time, and then takes the letters of the plaintext for substitution. Writing it under the plaintext, it results in first the key word, concatenated with the plaintext itself.</p>

<p>As example, the text „ATTACKATMIDNIGHT“ will
be encrypted with the key word “KEY”:</p>

<p> <img id="Grafik 0" src="encryption_example.png" alt="encryption_example.png" width="85%"></p>


<h3 id="Decryption">Decryption</h3>

<p>Receiving an Autokey-Vigenère ciphertext, how to decipher it, knowing just the key word? Initially, the decoder doesn’t know all substitution alphabets which were used for encryption – just the first few of them (the key word). Further, he knows, that the following, yet unknown substitution alphabets are (generated by) the subsequent plaintext letters. He
must now decipher the first part of the plaintext with the key word, decipher the next sequence of plaintext with these letters, and continue with the newly deciphered plaintext (= key sequence) letters, …</p>

<p>An example (deciphering the ciphertext from above) will make it a bit clear:</p>

<p><img id="Grafik 1" src="decryption_example.png" alt="decryption_example.png" width="85%" /></p>

<p>When the substitution alphabet is known, the decryption mechanism is equal to the normal Vigenère algorithm.</p>


<h2 id="furtherreading">Further reading</h2>
<ul>
  <li>
  	<a class="external" target="_blank" href="http://en.wikipedia.org/w/index.php?title=Autokey_cipher">
  	Wikipedia article on the Autokey-Vigenère cipher
  	</a>
  </li>
</ul>


</body>
</html>
