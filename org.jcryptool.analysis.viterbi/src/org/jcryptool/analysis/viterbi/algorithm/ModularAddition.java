//-----BEGIN DISCLAIMER-----
/*******************************************************************************
* Copyright (c) 2011, 2021 JCrypTool Team and Contributors
*
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*******************************************************************************/
//-----END DISCLAIMER-----
package org.jcryptool.analysis.viterbi.algorithm;

/**
 *
 * This class provides methods to combine characters or stings with an modular
 * addition. Two characters will be added or subtracted. The value for the
 * modulo operation is the size of the alphabet. (= Character.MAX_VALUE) If one
 * string is longer than the other, the shorter one will be repeated.
 *
 * @author Georg Chalupar, Niederwieser Martin, Scheuchenpflug Simon
 *
 */
public class ModularAddition implements Combination {

	/**
	 * Combines two strings by combining the characters at the same position.
	 * the combination is done by adding the integer-values of the chars modulo
	 * Character.MAX_VALUE. If the strings are not of equal length the shorter
	 * one will be repeated to fit the longer one.
	 *
	 * @param a
	 *            addend
	 * @param b
	 *            addend
	 * @return the result of the modular addition
	 */
	@Override
	public String add(String a, String b) {

		if (a.length() == 0 || b.length() == 0) {
			return "";
		}

		StringBuilder cipher = new StringBuilder("");
		double maxlength = a.length() > b.length() ? a.length() : b.length();

		for (int i = 0; i < maxlength; i++) {
			cipher.append((char) ((a.charAt(i % a.length()) + b.charAt(i
					% b.length())) % Character.MAX_VALUE));
		}
		return cipher.toString();
	}

	/**
	 * Combines two strings by combining the characters at the same position.
	 * the combination is done by subtracting the integer-values modulo
	 * Character.MAX_VALUE. If the strings are not of equal length the shorter
	 * one will be repeated to fit the longer one.
	 *
	 * @param a
	 *            minuend
	 * @param b
	 *            subtrahend
	 * @return difference
	 */
	@Override
	public String subtract(String a, String b) {

		if (a.length() == 0 || b.length() == 0) {
			return "";
		}

		StringBuilder cipher = new StringBuilder("");
		double maxlength = a.length() > b.length() ? a.length() : b.length();

		for (int i = 0; i < maxlength; i++) {
			cipher.append((char) ((a.charAt(i % a.length())
					- b.charAt(i % b.length()) + Character.MAX_VALUE) % Character.MAX_VALUE));
		}
		return cipher.toString();
	}

	/**
	 * Combines two characters by adding the integer-values modulo
	 * Character.MAX_VALUE.
	 *
	 * @param a
	 *            addend
	 * @param b
	 *            addend
	 * @return the result of the modular addition
	 */
	@Override
	public char add(char a, char b) {
		return (char) ((a + b) % Character.MAX_VALUE);
	}

	/**
	 * Combines two characters by subtracting the integer-values modulo
	 * Character.MAX_VALUE.
	 *
	 * @param a
	 *            minuend
	 * @param b
	 *            subtrahend
	 * @return difference
	 */
	@Override
	public char subtract(char a, char b) {
		return (char) ((a - b + Character.MAX_VALUE) % Character.MAX_VALUE);
	}

	/**
	 * Calculates last position until two equal strings could generate the given ciphertext
	 * @param cipher a ciphertext generated by modular adding two plaintexts
	 */
	@Override
	public int getMaxDuplicatePathLength(String cipher) {
		for (int i = 0; i < cipher.length(); i++) {
			if (cipher.charAt(i)%2!=0) {
				return i;
			}
		}
		return 0;
	}
}
