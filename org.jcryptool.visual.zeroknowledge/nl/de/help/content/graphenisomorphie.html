<!DOCTYPE html>
<html lang="de">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Graphenisomorphie</title>
  <script id="MathJax-script" async src="${JCTJS_HOST}/javascript/MathJax-master/es5/tex-mml-svg.js"></script>
</head>

<body>

	<h1>Graphenisomorphie</h1>

	<h2>Zweck</h2>

	<p>Alice will Bob beweisen, dass sie einen Isomorphismus \(f\) kennt,
	der den Graphen \(G_0\) in den Graphen \(G_1\) transferiert, kennt. Der Beweis
	soll ablaufen, ohne dass Alice ihr Geheimnis oder Teile davon verrät.
	</p>

	<h2>Anwendung</h2>

	<ol>
		<li>Alice wählt zufällig ein Bit a (\(0\) oder \(1\)) und erstellt einen neuen Isomorphismus
		\(g\) welcher als Ergebnis den neuen Graphen \(H\) erhält wenn sie \(g(G_a)\) berechnet.
		\(H\) wird dann an Bob gesendet.</li>
		<li><p>Bob wählt nun seinerseits zufällig ein Bit \(b\) (\(0\) oder \(1\)) und sendet dieses
		an Alice. Er fragt sie nach einem Isomorphismus \(h\) welcher folgende Gleichung
		erfüllt:</p>
		
		\( \style{text-align:left;} {
		\begin{align*}
			H = h(G_b)
		\end{align*}
		} \)

		<li>
		<p> Falls \(a = b\) gilt, erhalten wir folgende vereinfachte Gleichung:</p>
		
		\( \style{text-align:left;} {
		\begin{align*}
			g(G_b) = H = h(G_b)
		\end{align*}
		} \)
		
		<p>In diesem Fall kann Alice einfach ihren vorher generierten Isomorphismus \(g\) an Bob
		senden.<br/>
		Falls \(a \neq b\) gilt, kann Alice nicht einfach \(g\) an Bob senden weil die beiden
		Isomorphismen in diesem Fall unterschiedlich sein müssen (\(g(G_a) = H = g(G_b)\) ist nicht erfüllbar falls \(G_a \neq G_b\)).
		Sie ist des Weiteren nicht in der Lage, direkt einen Isomorphismus \(h\) von \(G_b\) nach \(H\) zu erstellen, weil
		dies ein NP-schweres Problem ist.<br>
		Jedoch kennt Alice einen Isomorphismus \(f\) von \(G_0\) nach \(G_1\), diesen kann sie anwenden um
		\(f(G_b) = G_a\) zu erhalten, wenn \(a \neq b\).
		Über diesem Umweg ist es ihr möglich die gewünschte Funktion zu liefern:</p>
		
		
		\( \style{text-align:left;} {
		\begin{align*}
			h(G_b) = H = g(f(G_b))
		\end{align*}
		} \)
		</li>
		<li><p>Bob erhält und überprüft \(H = h(G_b)\).</p></li>
	</ol>

	<h2>Verwundbarkeit</h2>

	<p>Carol, der Angreifer, kennt den Isomorphismus \(f\), welcher \(G_0\) in \(G_1\)
	überführt, nicht. Aus diesem Grund ist sie nicht in der Lage Bob
	einen Isomorphismus zu liefern wenn \(a \neq b\) ist (Punkt Nummer 3 weiter
	oben für die Herleitung beachten).
	Aber falls \(a = b\) gilt wäre \(h = g\), da sie \(g\) selber wählen kann, kann sie
	in diesem Fall erfolgreich den Test bestehen. Hierfür muss sie erraten
	welchen Wert Bob für \(b\) wählt.</p>

	<p>Die Wahscheinlichkeit richtig zu raten liegt bei \(50\,\%\) \((0\) oder \(1)\).
	Wenn zehn aufeinanderfolgende Iterationen des Protokolls
	durchlaufen werden hätten wir somit eine Betrugswahrscheinlichkeit von weniger
	als \(0.1\,\%\) \((0.5^{10})\). Wird \(2^{80}\) als Untergrenze für sichere kryptografische
	Operationen angesehen, sind \(80\) Iterationen notwendig.</p>

	<p>Ein Protokolldurchlauf von \(1 <= k <= 20\) Iterationen kann simuliert werden
	durch einen Klick auf den Button <b>mehrmals durchführen</b>.</p>

</BODY>
</HTML>
