<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Das ElGamal-Kryptosystem</title>
</head>

<body>
  <h1>ElGamal-Kryptosystem (Verschlüsseln, Entschlüsseln, Signieren und Verifizieren)</h1>

  <p>This help file describes two things:<br/>
  1) <a href="#scheme-general">The ElGamal Scheme (Algorithm)</a><br/>
  2) <a href="#plugin">Handling Instructions: How to Use this Visualization</a> </p>

  <h2 id="scheme-general">1) The ElGamal Scheme (Algorithm)</h2>
  
  <p>The ElGamal <b>encryption</b> scheme is an asymmetric encryption scheme which is based on the idea of the Diffie-Hellman key exchange. It was first described by Taher Elgamal in 1985.</p>
  
  <p>The ElGamal <b>signature</b> scheme is a digital signature scheme which is based on the difficulty to compute discrete logarithms. It was first described by Taher ElGamal in 1984.</p>
  
  <p>While the ElGamal signature scheme is rarely used, the ElGamal encryption is widely used as an alternative to RSA encryption.
  The setup and the generation (of the private and the public key) are the same for both schemes. However, encryption and signing work differently. In the opposite to the <a href="../../../../../org.jcryptool.visual.rsa/nl/en/help/content/index.html">RSA cryptosystem</a>, ElGamal depends on the difficulty of solving discrete logarithms while RSA depends on the factorization of big numbers. Another difference is, that ElGamal encryption and signing need an additional random session key and so is probabilistic, what RSA isn't.</p>
  
  <p>As usual, we use the scenario with Alice sending a message to Bob. For encrypting the message, she needs his public key; for signing it she uses her private key.</p>
  
  <p>Like all asymmetric cryptosystems, the ElGamal cryptosystem uses for each participant (Alice and Bob) a key pair consisting of a public and a private key. in the encryption case, a public key is used for encryption and can be published, while a private key is used for decryption and must only be known to the recipient of the message. This means that Bob, the recipient of the message, must generate a key pair only once. Afterwards, Alice and everyone else can use his public key to encrypt messages as often as they like and send these encrypted messages to Bob.</p>

  <p>In the following we have four sections: <a href="#Setup">a) parameter generation (setup)</a>, <a href="#KeyGen">b) key generation</a>, <a href="#SchemeEncDec">c) encryption</a>, and <a href="#SchemeSigVer">d) signing</a>. The first two components are used by both schemes. The third and fourth component are different for the two schemes ElGamal encryption and ElGamal signature.</p>
  
  <h3 id="Setup">a) ElGamal Setup (Parameter Generation)</h3>
  
  <p> ElGamal encryption can be defined over any cyclic group G with a finite order.</p>

  <p>Alice and Bob both use the same cyclic (aka finite) group G with d elements (aka the group is of order d). This group is generated with the generator g where g is an element of G. d is an n-bit integer. The input for the generation process is normally the security parameter n. All of this data is made public. As G often Z_d = { 0, … , d-1 } is used with a prime d.</p>

  <p><b>Note 1:</b> The randomly chosen d should be large and have a similar size as an RSA modulus (1024 - 4096 bit).</p>
  <p><b>Note 2:</b> The generator g is a special number and must be a primitive root (aka primitive element) of G.</p>
  
  
  <h3 id="KeyGen">b) ElGamal Key Generation</h3>

  <p> The key generation is done only once per subject.</p>

  <p>For encryption we need Bob's public key. His key generation works like this:</p>
  <ul>
  <li>Bob chooses b randomly from Z*_d = { 1, … , d-1 } with 1 < b < d-2. This is his private key.</li>
  <li>Bob computes B = g^b. This is (part of) his public key.</li>
  <li>Bob publishes B, along with the description of G, d, g, as his public key. Bob retains b as his private key, which must be kept secret.</li>
  </ul>

  <p>For the signature of Alice we need Alice's private key. Her key generation works like this:</p>
  <ul>
  <li>Alice chooses a randomly from Z*_d = { 1, … , d-1 } with 1 < a < d-2. This is her private key.</li>
  <li>Alice computes A = g^a. This is (part of) her public key.</li>
  <li>Alice publishes A, along with the description of G, d, g, as her public key. Alice retains a as her private key, which must be kept secret.</li>
  </ul>

  <p><b>Note:</b> The values of d and g are determined independently by Alice and Bob. For encryption, the values from Bob are needed; for signing the values from Alice are needed.</p>

  
  <h3 id="SchemeEncDec">c) ElGamal Encryption / Decryption</h3>

  <p>The ElGamal encryption scheme consists of four steps: the parameter generation (setup), the key generation, the encryption, and the decryption. The first two steps were described above, the actual encryption and decryption follow now.</p>
  
  <h4 id="SchemeEnc">c1) ElGamal Encryption</h3>

  <p>The encryption algorithm works as follows: To encrypt a plaintext message m for Bob she uses his public key ( G, d, g, B ), and</p>
  <ul>
  <li>Alice chooses a random secret session key k from { 1, … , d-1 }.</li>
  <li>Alice calculates a public session key K = g^k.</li>
  <li>Alice calculates the shared secret S = B^k = g^(b*k).</li>
  <li>Alice maps her message m onto an element m' of G.</li>
  <li>Alice calculates M = m' * S.</li>
  <li>Alice sends the ciphertext (K, M) = ( g^k, m' * S) = (g^k, m' * g^(b*k)) to Bob.</li>
  </ul>

<p><b>Note 1:</b> One can easily find B^k if one knows m'. Therefore, a new k is generated for every message to improve security. For this reason, k is also called an ephemeral (or session) key.</p>
<p><b>Note 2:</b> With Diffie-Hellman key exchange, Alice would send A=g^a to Bob, so he can create the shared session key as S = A^b. With ElGamal encryption, Alice doesn't use her private key a, but a secret session key k. The remaining logic is the same.</p>
<p><b>Note 3:</b> With ElGamal encryption, the ciphertext is twice as long as the plaintext (message expansion).</p>
<p><b>Note 4:</b> ElGamal encryption is a probabilistic encryption: The ciphertext not only depends on the public key of the receiver but also on a random k. So each time the same plaintext is encrypted using the same public key, the resulting ciphertext should be different.</p>

    
  <h4 id="SchemeEnc">c2) ElGamal Decryption</h3>

  <p>The decryption algorithm works as follows: To decrypt a ciphertext (K, M) sent to Bob he uses his private key b, and</p>
  <ul>
  <li>Bob calculates the shared secret S = K^b = g^(k*b).</li>
  <li>Bob computes S^(-1) which is the inverse of S in the group G.</li>
  <li>Bob computes m' = M * S^(-1).</li>
  <li>Bob then converts m' back into the plaintext message m.</li>
  </ul>

<p>Note that the decryption algorithm produces the intended message, since M * S^(-1) = [m' * g^(b*k)] * (g^(b*k))^(-1) = m' * g^(bl) * g^(-bk) = m'.</p>

  
  
  <h3 id="SchemeSigVer">d) ElGamal Signing / Verifying</h3>

  <p>Like any signature scheme, the ElGamal signature scheme allows a third-party to confirm the authenticity of a message. The ElGamal signature scheme consists of four steps: the parameter generation (setup), the key generation, the signing, and the verifying. The first two steps were described above, the actual signing and verification follow now.</p>

  <p> In addition to the setup parameters above, a collision-resistant hash function H is needed.</p>
  <p> As G, usually Z*_d = { 1, … , d-1 } is used with a large prime d, such that computing discrete logarithms modulo d is difficult. </p>
  
  
  <h4 id="SchemeEnc">d1) ElGamal Signing</h3>
  <p>We assume Alice to be the signer.</p>
  
  <p>The signing algorithm works as follows: To sign a message m Alice uses her private key a, and</p>
  <ul>
  <li>Alice chooses a random secret session key k from { 2, … , d-2 } with gcd(k, d-1) = 1.</li>
  <li>Alice calculates the public session key K = g^k mod d.</li>
  <li>Alice calculates s = k^(-1) * ( H(m) - a*K )  mod d-1.</li>
  <li>If s=0 start again.</li>
  <li>Alice sends the pair (K, s) which is the signature of m to Bob.</li>
  </ul>

    
  <h4 id="SchemeEnc">d2) ElGamal Verifying</h3>
  <p>We assume Bob to verify the message signed by Alice.</p>

  <p>The verification algorithm works as follows: To verify a message m from Alice he uses her public key ( G, d, g, A ), the received signature (K, s), and</p>
  <ul>
  <li>Bob checks that 0 < K < d and 0 < s < p-1.</li>
  <li>Bob computes u = g^(H(m))  mod d.</li>
  <li>Bob computes v = A^K * K^s  mod d.</li>
  <li>If K != 1 and u = v, then the signature is correct, else it is invalid (doesn't fit to m or not signed with Alice's private key).</li>
  </ul>

<p>Note that the verification algorithm is correct in the sense that a signature generated with the signing algorithm will always be accepted by the verifier, since from the signature generation 
<br/>
  s = k^(-1) * ( H(m) - a*K )  mod d-1 <br/>
  H(m) = k*s + a*K  mod d-1 <br/>
and then because of Fermat's little theorem<br/>
  u <br/>
  = g^(H(m))  mod d <br/>
  = g^(k*s) * g^(a*K)  mod d <br/>
  = (g^k)^s * (g^a)^K  mod d <br/>
  = K^s * A^K  mod d <br/>
  = v <br/></p>


  
<p><br/></p>  
  <h3 id="NotationElGamal">e) Notation Used for ElGamal Encryption / Signing</h3>

  <p>We used a and A for the private and public key of the sender Alice, and b and B for the private and public key of the entity Bob, as this is the usual way the scenario of Diffie-Hellman key exchange is described, and so we have no overlap when describing ElGamal encryption and ElGamal signing. Capital letters represent always powers with the base g.</p>

  <p>Other authors and the English Wikipedia use independent notation for ElGamal encryption and ElGamal signing. So in case of encryption the private key is called x and the according public key is y. And another author uses x as name for the message as this is the variable input for the encryption function.</p>

  <p>Here we present a table which maps the different notations: the one oriented on the Diffie-Hellman key exchange (DH) which is used here, and the one used in der deutschen (aber nicht der Englischen) Wikipedia (Dezember 2017).</p>

<p></p>
<style>
table, th, td {
    font-family: arial, sans-serif;
    border: 1px solid black;
    border-collapse: collapse;
    text-align: left;
    padding: 8px;
}
</style>

 <table style="width:100%">
  <caption>Notationen &nbsp;&ndash; Vergleich für ElGamal-Verschlüsselung</caption>
  <tr>
    <th>DH-orientiert</th>
    <th>Deutsche Wikipedia</th>
    <th>Phase / Bedeutung</th>
  </tr>
  <tr>
    <td>d</td>
    <td>p/td>
    <td>Setup: Anzahl der Elemente in G / große Primzahl</td>
  </tr>
  <tr>
    <td>g</td>
    <td>g</td>
    <td>Setup: Generator von G</td>
  </tr>

  <tr>
    <td>b</td>
    <td>a</td>
    <td>Key Gen: Privater Schlüssel des Empfängers</td>
  </tr>
  <tr>
    <td>B</td>
    <td>A</td>
    <td>Key Gen: Öffentlicher Schlüssel des Empfängers</td>
  </tr>

  <tr>
    <td>m</td>
    <td>m</td>
    <td>Verschlüsselung: Gegebener Klartext, bevor auf ein Element in G gemappt</td>
  </tr>
  <tr>
    <td>m'</td>
    <td>m</td>
    <td>Verschlüsselung: Klartext (Nachricht), schon gemappt auf ein Element in G</td>
  </tr>
  <tr>
    <td>k</td>
    <td>r (manchmal auch y)</td>
    <td>Verschlüsselung: Zufällige Zahl, die pro Nachricht zu erzeugen ist (geheimer Sessionkey)</td>
  </tr>
  <tr>
    <td>K</td>
    <td>R</td>
    <td>Verschlüsselung: Öffentlicher Sessionkey (neu pro Nachricht)</td>
  </tr>
  <tr>
    <td>S</td>
    <td>-</td>
    <td>Verschlüsselung: Geheimer Shared Key (for one message)</td>
  </tr>
  <tr>
    <td>M</td>
    <td>c</td>
    <td>Verschlüsselung: Verschlüsseltes m'</td>
  </tr>
  <tr>
    <td>(K,M)</td>
    <td>(R, c)</td>
    <td>Verschlüsselung: Geheimtext</td>
  </tr>
</table> 

<p><br/></p>


 <table style="width:100%">
  <caption>Notationen &nbsp;&ndash; Vergleich für ElGamal-Signaturen (Setup gleich wie oben)</caption>
  <tr>
    <th>DH-orientiert</th>
    <th>Deutsche Wikipedia</th>
    <th>Phase / Bedeutung</th>
  </tr>
  <tr>
    <td>a</td>
    <td>a</td>
    <td>Key Gen: Privater Schlüssel des Signierenden</td>
  </tr>
  <tr>
    <td>A</td>
    <td>A</td>
    <td>Key Gen: Öffentlicher Schlüssel des Signierenden</td>
  </tr>

  <tr>
    <td>m</td>
    <td>m</td>
    <td>Signieren: Klartext</td>
  </tr>
  <tr>
    <td>H(m)</td>
    <td>H(m)</td>
    <td>Signieren: Hashvalue des Klartexts</td>
  </tr>
  <tr>
    <td>k</td>
    <td>k</td>
    <td>Signieren: Zufällige Zahl, die pro Nachricht zu erzeugen ist (geheimer Sessionkey)</td>
  </tr>
  <tr>
    <td>K</td>
    <td>r</td>
    <td>Signieren: Öffentlicher Sessionkey (einer je Nachricht)</td>
  </tr>
  <tr>
    <td>s</td>
    <td>s</td>
    <td>Signieren: Zweiter Teil der Signatur</td>
  </tr>
  <tr>
    <td>(K,s)</td>
    <td>(r,s)</td>
    <td>Signieren: Signatur von m'</td>
  </tr>
</table> 
<p><br/></p>















  
 <br/>  
  <h2 id="plugin">2) Handling Instructions: How to Use this Visualization</h2>
  <p> When the ElGamal visualization is started, you can select the desired operation, encrypt, decrypt, sign, or verify&nbsp;&ndash; by choosing the corresponding tab.</p>

  <p>Each tab has on the left 4 or 5 buttons to proceed:<br/>
  - select the key of the subject<br/>
  - choose additional parameters for the session key<br/>
  - enter the text (message) to be processed<br/>
  - calculate the result either in one step or step-by-step.</p>

  <p>In the step-by-step mode the intermediate calculations are shown too.<br/>
  After the data for a step is entered and the step is processed, the color of the button changes from red to green.</p>
 
  <p>The fields at the right are just for showing the data (view part). You can enter the necessary data only within the dialog boxes which come up after pressing the buttons at the left. These dialogs take care to check the entered data for correctness.</p>
    
  <p>At the bottom you find the options:<br/>
  - More details for key generation.<br/>
  - A drop-down control to copy the data from another tab.<br/>
  - Optionally you can enable additional message boxes which
    explain the steps in more details.<br/>
  - The <b>Reset</b> button just deletes the calculations. It does not delete the
    entered text, the chosen key, and the chosen parameter.</p>
	
  <p>If you want the plugin to show the visualization in the initial state, click at the small icon <b>Restart</b> in the upper left.</p>


  <p><br/>xxxxxxxxxxxxxx</p>
  
  TODO in der GUI des Plugins: SOFORT<br/>
        - bei encrypt: Enter text --> Enter plaintext<br/>
        - bei decrypt: Enter text --> Enter ciphertext<br/>
		             --> Entweder direkt eingeben oder von Tab "Sign" holen.<br/>
        - bei sign   : Enter text --> Enter plaintext<br/>
        - bei verify : Enter text --> Enter plaintext<br/>
        //TG Buttons umbenannt<\br>
		             --> Hier müsste es einen weiteren Button "Enter signature" geben:<br/> Dann diese von Hand eingeben oder die berechnete Signatur vom Tab Sign herüberkopieren.<br/><br/>
  TODO in der GUI des Plugins bei encrypt: SPÄTER<br/>
		- Variablennamen umbenennen, damit passend zur Onlinehilfe:<br/>
           A -> B, a -> b, b -> k, B -> K, c -> M <br/>	<br/>
  TODO in der GUI des Plugins bei encrypt: SPÄTER<br/>
		In der Gruppierung mit den detaillierten Schritten:<br/>
		- Neue Variable einfügen: S=B^k,<br/>
		  so dass M berechnet wird als S*m<br/>
		- b (neu k) sollte oben angezeigt werden hinter "Parameter wählen"<br/>
		  und dafür hier nicht mehr.<br/>	<br/>
  TODO in der GUI des Plugins bei encrypt: SPÄTER<br/>
		Bei allen Zahlen (nach "Schlüssel wählen" und nach "Parameter wählen")<br/>
		  sollte man zwischen Dec und Hex umschalten können, damit klar ist,<br/>
		  dass bspw. g = 2832 = b10<br/>

  <p></p>
    TODO zur Plugin-Funktionalität: SPÄTER:<br/>
	Sollte man nicht zusätzlich eine Auswahl mit mehreren Hashverfahren anbieten und das einfache mit der Quersumme nur als Default nehmen (das einfache erlaubt das Arbeiten mit sehr kleinen Parametern). Man sollte den Hashwert auch noch manuell eingeben können, um Beispiele in der Literatur durchspielen zu können.

  <p>xxxxxxxxxxxxxx</p>
  
  
 <br/>  
  <h3 id="Sig">Weitere Information / Referenzen</h3>
  <p>For further information about the ElGamal cryptosystems please refer to:</p>
  <ul>
  <li><a href="http://www.springer.com/de/book/9783662484234">Joachim von zur Gathen: CryptoSchool, Springer, 2015, Kapitel 4.2 und 8.2</a></li>
  <li><a href="http://www.oxfordscholarship.com/view/10.1093/acprof:oso/9780199695591.001.0001/acprof-9780199695591">Keith M. Martin: Everyday Cryptography, Oxford, 2012, Kapitel 5.3 und A.4</a></li>
  <li><a href="https://de.wikipedia.org/wiki/Elgamal-Verschl%C3%BCsselungsverfahren">Wikipedia: ElGamal-Verschlüsselungsverfahren</a></li>
  <li><a href="https://de.wikipedia.org/wiki/Elgamal-Signaturverfahren">Wikipedia: ElGamal-Signaturverfahren</a></li>
  <li><a href="https://www.cryptool.org/images/ctp/documents/CT-Book-depdf">Das CrypTool-Buch, Kapitel 5</a></li>
  </ul>

  <br/>
</body>
</html>